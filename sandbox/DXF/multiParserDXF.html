<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Parser DXF</title>
</head>

<body>
    <h2>Sube tu archivo DXF</h2>
    <input type="file" id="fileInput"><br><br>

    <label for="selector">Seleccionar tipo de entidad:</label>
    <select id="selector" onchange="dispara()">
        <option value="LINE">LINE</option>
        <option value="TEXT">TEXT</option>
        <option value="MTEXT">MTEXT</option>
        <option value="SOLID">SOLID</option>
    </select>

    <h3>Resultado:</h3>
    <textarea id="salida" rows="20" cols="100" readonly></textarea>

    <script>

        // Aseguramos persistencia para el onchange del selector
        let dxfTextGlobal = null;

        document.getElementById('fileInput').addEventListener('change', function (e) {
            const reader = new FileReader();
            reader.onload = function () {
                dxfTextGlobal = reader.result;
                dispara(reader.result);
            };
            reader.readAsText(e.target.files[0]);
        });

        document.getElementById('selector').addEventListener('change', function () {
            if (dxfTextGlobal !== null) {
                dispara(dxfTextGlobal);
            }
        });

        function dispara(dxfTextGlobal = null) {
            const tipo = document.getElementById('selector').value;
            const text = dxfTextGlobal || window.dxfTextGlobal;
            if (text) {
                const result = parseDXF(text, tipo);
                document.getElementById('salida').value = result.join('\n');
            }
        }

        function fmt(n) {
            return parseFloat(n).toFixed(3).replace(/\.?0+$/, '').padStart(5);
        }

        function parseDXF(dxfText, tipo) {
            const lines = dxfText.split(/\r?\n/);
            const result = [];

            for (let i = 0; i < lines.length; i++) {
                const code = lines[i].trim();

                if (code === '0') {
                    const entityType = lines[i + 1]?.trim();
                    if (entityType === tipo) {
                        switch (tipo) {
                            case 'LINE':
                                result.push(...parseLINE(lines, i));
                                break;
                            case 'TEXT':
                                result.push(...parseTEXT(lines, i));
                                break;
                            case 'MTEXT':
                                result.push(...parseMTEXT(lines, i));
                                break;
                            case 'SOLID':
                                result.push(...parseSOLID(lines, i));
                                break;
                        }
                    }
                }
            }

            return result;
        }

        function parseLINE(lines, startIndex) {
            let x1 = "    0", y1 = "    0", x2 = "    0", y2 = "    0", grosor = "    0";

            for (let i = startIndex + 2; i < lines.length; i += 2) {
                const code = lines[i].trim();
                const value = lines[i + 1]?.trim();

                if (code === '0') break;

                switch (code) {
                    case '10': x1 = fmt(value); break;
                    case '20': y1 = fmt(value); break;
                    case '11': x2 = fmt(value); break;
                    case '21': y2 = fmt(value); break;
                    case '370': grosor = fmt(value); break;
                }
            }

            return [(`entidades.push(lineaDXF( posX + ${x1}, posY + ${y1}, posX + ${x2}, posY + ${y2}, ${grosor}));  // LINE en línea ${startIndex}`).replace(/\+\s*-/g, "- ")];

        }

        function parseTEXT(lines, startIndex) {

            const data = {
                x: '    0', y: '    0', height: '  2.5', rotation: '    0',
                text: '', align: 'ML', useAlignPoint: false,
                ax: null, ay: null // alternate alignment point
            };

            for (let i = startIndex + 2; i < lines.length; i += 2) {
                const code = lines[i].trim();
                const value = lines[i + 1]?.trim();

                if (code === '0') break;

                switch (code) {
                    case '10': data.x = value; break;
                    case '20': data.y = value; break;
                    case '11': data.ax = value; data.useAlignPoint = true; break;
                    case '21': data.ay = value; data.useAlignPoint = true; break;
                    case '40': data.height = value; break;
                    case '50': data.rotation = value; break;
                    case '1': data.text = value.replace(/^{|}$/g, ''); break;
                    case '72': data.hAlign = parseInt(value); break;
                    case '73': data.vAlign = parseInt(value); break;

                }
            }


            const posX = fmt(data.useAlignPoint && data.ax !== null ? data.ax : data.x);
            const posY = fmt(data.useAlignPoint && data.ay !== null ? data.ay : data.y);
            const height = fmt(data.height);
            const rotation = fmt(data.rotation);

            const horiz = ['L', 'C', 'R'][data.hAlign ?? 0] || 'L';
            const vert = { 1: 'B', 2: 'M', 3: 'T' }[data.vAlign ?? 2] || 'M';
            data.align = vert + horiz;

            return [(`entidades.push(textoDXF( posX + ${posX},  posY + ${posY}, "${data.text}", ${height}, ${rotation}, "${data.align}"));  // TEXT en línea ${startIndex}`).replace(/\+\s*-/g, "- ")];

        }


        function parseMTEXT(lines, startIndex) {
            const data = {
                x: '    0', y: '    0', height: '  2.5', rotation: '    0',
                rawText: '', align: 'ML'
            };

            for (let i = startIndex + 2; i < lines.length; i += 2) {
                const code = lines[i].trim();
                const value = lines[i + 1]?.trim();

                if (code === '0') break;

                switch (code) {
                    case '10': data.x = value; break;
                    case '20': data.y = value; break;
                    case '40': data.height = value; break;
                    case '50': data.rotation = value; break;
                    case '1':
                    case '3':
                    case '4':
                        data.rawText += value.replace(/^{|}$/g, '');
                        break;
                    case '71': // Alignment
                        switch (value) {
                            case '1': data.align = 'TL'; break;
                            case '2': data.align = 'TC'; break;
                            case '3': data.align = 'TR'; break;
                            case '4': data.align = 'ML'; break;
                            case '5': data.align = 'MC'; break;
                            case '6': data.align = 'MR'; break;
                            case '7': data.align = 'BL'; break;
                            case '8': data.align = 'BC'; break;
                            case '9': data.align = 'BR'; break;
                        }
                        break;
                }
            }

            const posX = fmt(data.x);
            const posY = fmt(data.y);
            const height = fmt(data.height);
            const rotation = fmt(data.rotation);

            // Separadores de líneas en MTEXT: \P, ^J, ^p
            const linesArray = JSON.stringify(
                data.rawText
                    .split(/\\P|\^J|\^p/i)
                    .map(s => s.trim())
                    .filter(s => s.length > 0)
            );

            return [(`entidades.push(textoMultiDXF( posX + ${posX},  posY + ${posY}, ${linesArray}, ${height}, ${rotation}, "${data.align}"));  // MTEXT en línea ${startIndex}`).replace(/\+\s*-/g, "- ")];
        }


        function parseSOLID(lines, startIndex) {
            const coords = [null, null, null, null]; // [ [x,y], [x,y], [x,y], [x,y] ]
            let current = 0;

            for (let i = startIndex + 2; i < lines.length; i += 2) {
                const code = lines[i].trim();
                const value = lines[i + 1]?.trim();

                if (code === '0') break;

                switch (code) {
                    case '10': case '11': case '12': case '13':
                        if (!coords[current]) coords[current] = [];
                        coords[current][0] = parseFloat(value);
                        break;
                    case '20': case '21': case '22': case '23':
                        if (!coords[current]) coords[current] = [];
                        coords[current][1] = parseFloat(value);
                        current++;
                        break;
                }
            }

            // Normalización para que tenga 4 vértices válidos
            if (coords.length === 3) coords.push([...coords[2]]);

            const fmtX = (n) => "posX + " + parseFloat(n).toFixed(3).replace(/\.?0+$/, '').padStart(5);
            const fmtY = (n) => "posY + " + parseFloat(n).toFixed(3).replace(/\.?0+$/, '').padStart(5);

            const formatted = coords.map(p => `[${fmtX(p[0])}, ${fmtY(p[1])}]`).join(', ');
            return [(`entidades.push(generarSolidDXF([${formatted}]));  // SOLID en línea ${startIndex}`).replace(/\+\s*-/g, "- ")];
        }


    </script>
</body>

</html>